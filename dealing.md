# Random Dealing
1. Everyone generates a RSA private key.
3. Everyone submits their RSA public key
* Their ID is the hash of their public key.

Then, to facilitate random number generation that's agreed on by the group, the group generates a shared random number
`groupRandom = hash(everyone's ID, sorted from least to greatest)`
Then each person generates a random number that is dependant on the group random number but is different for each person
`localRandom = hash(groupRandom + my ID)`


Then in order to prevent duplicates, we split up the deck into numPlayers segments. 
Here's how you do this:

1. Make a random number generator, seeded by the string `groupRandom + "whiteCards"`
2. Use that random number generator to shuffle the white cards
3. Split this deck into `numPlayers` equal segments
4. Assign each player a segment, going in order of player ID from least to greatest

Now every player has a list of cards that they could draw (called a subdeck)

Then each player selects `n` cards from their segment to be their hand.
First they select random numbers `myRandom[0...n]`. They keep these secret.
Here's how they calculate the cardIndex of card i of their hand: `cardIndex[i]=hash(localRandom + myRandom[i] + i) % mySubDeckLength`

Now that each player knows what cards are in their hand, they construct a merkle tree where the leaf nodes are the card indexes in their hand. Each player submits the merkle root of their hand, signed with their private key. (the signed part is optional, idk)


The point of all this is so that each player has a secret set of cards in their hand, but at any point can prove that a given card is in their hand.
In order to prove that I really have `cards[i]`, I have to provide `myRandom[i]`, then others can verify that I calculated `cards[i]` correctly (using the equation above). Then I need to prove that that is a part of the merkle tree root, which I do with a normal merkle proof.
So basically I need to prove that I calculated `cards[i]` correctly, as well as that `cards[i]` is a part of my hand.



-----

Here's how it works to actually play the game. What should happen is that everyone gives a card face down to the judge, the judge flips them over, picks one, then the person who submitted that card says "hey that was me".
	This is made easier by the fact that there are no duplicate cards.
	Here's how we do that in a p2p way:

* STEP 1: everyone gives a facedown card to the judge
		Everyone picks a card, and encrypts it with the judge's public key.
		Then they send the encrypted cards to each other. Whenever someone who isn't the judge receives an encrypted card, they forward it to three other random people (which may include the judge).
		Why do this? Because now the judge is receiving encrypted cards from random people, not necesarily the same person as who picked the card. This ensures that the judge doesn't know who submitted what card.
		So now the judge has all the encrypted cards.

* STEP 2: judge flips them over and picks one
		Judge decrypts cards with its private key. User picks one.
		Judge signs the decision with its private key, and sends to everyone.

* STEP 3: person who submitted winning cards claims winnings
		This is easy: this person generates the merkle/hash proof discussed earlier and gives it to everyone. 
		Everyone agrees that that person won by verifying the proof.




Also, the order of who is judge when is generated by taking the list of users, and randomizing them according to the key `groupRandom`. 




Now people need to draw another card...



